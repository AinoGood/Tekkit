if game:IsLoaded() then
    print("Game loaded, executing script")
else
    print("Game not loaded, waiting for game to load")
    wait(5)
end



-- Gui to Lua
-- Version: 3.2

-- Instances:

local Tekkit = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local Title = Instance.new("TextLabel")
local tpButtonF = Instance.new("TextButton")
local farmText = Instance.new("TextLabel")

--Properties:

Tekkit.Name = "Tekkit"
Tekkit.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
Tekkit.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Frame.Parent = Tekkit
Frame.BackgroundColor3 = Color3.fromRGB(68, 68, 68)
Frame.BackgroundTransparency = 0.300
Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.409745306, 0, 0.37794435, 0)
Frame.Size = UDim2.new(0.180287942, 0, 0.208137065, 0)

Title.Name = "Title"
Title.Parent = Frame
Title.BackgroundColor3 = Color3.fromRGB(68, 68, 68)
Title.BackgroundTransparency = 0.300
Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
Title.BorderSizePixel = 0
Title.Size = UDim2.new(1, 0, 0.200000003, 0)
Title.Font = Enum.Font.SourceSans
Title.Text = "Tekkit Aot:R"
Title.TextColor3 = Color3.fromRGB(0, 0, 0)
Title.TextScaled = true
Title.TextSize = 14.000
Title.TextWrapped = true

tpButtonF.Name = "tpButtonF"
tpButtonF.Parent = Frame
tpButtonF.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
tpButtonF.BackgroundTransparency = 0.500
tpButtonF.BorderColor3 = Color3.fromRGB(0, 0, 0)
tpButtonF.BorderSizePixel = 0
tpButtonF.Position = UDim2.new(0.673999369, 0, 0.351959795, 0)
tpButtonF.Size = UDim2.new(0.121498786, 0, 0.203919873, 0)
tpButtonF.Font = Enum.Font.SourceSans
tpButtonF.Text = ""
tpButtonF.TextColor3 = Color3.fromRGB(0, 0, 0)
tpButtonF.TextSize = 14.000

farmText.Name = "farmText"
farmText.Parent = Frame
farmText.BackgroundColor3 = Color3.fromRGB(68, 68, 68)
farmText.BackgroundTransparency = 0.300
farmText.BorderColor3 = Color3.fromRGB(0, 0, 0)
farmText.BorderSizePixel = 0
farmText.Position = UDim2.new(0.0829242021, 0, 0.351959944, 0)
farmText.Size = UDim2.new(0.440909207, 0, 0.203920364, 0)
farmText.Font = Enum.Font.SourceSans
farmText.Text = "AutoFarmer"
farmText.TextColor3 = Color3.fromRGB(255, 255, 255)
farmText.TextScaled = true
farmText.TextSize = 14.000
farmText.TextWrapped = true

Frame.Draggable = true
Frame.Selectable = true
Frame.Active = true


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local player = game.Players.LocalPlayer
local playername = player.Name
local playermodel = game.Workspace.Characters:WaitForChild(playername)
local rig = playermodel:WaitForChild("Rig_" .. playername)
local parentObject = rig:WaitForChild("LeftHand")
local childObject = parentObject:WaitForChild("Blade_1")

local function isPC()
    return not game:GetService("UserInputService").TouchEnabled
end

local pc = isPC()
local nape
local nape2
local isTeleportEnabled = false
local MAX_TELEPORT_DISTANCE2 = math.huge

-- Function to get the LocalPlayer's HumanoidRootPart location
local function getLocalPlayerHumanoidRootPartLocation()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    if humanoidRootPart and humanoidRootPart:IsA("BasePart") then
        local humanoidRootPartLocation = humanoidRootPart.Position
        print("HumanoidRootPart Location:", humanoidRootPartLocation)
        return humanoidRootPartLocation
    else
        warn("HumanoidRootPart not found for LocalPlayer.")
        return nil
    end
end

-- Function to find the closest Nape location within the maximum teleport distance
local function findClosestNapeLocation()
    local titansFolder = Workspace:FindFirstChild("Titans")
    local closestNapeLocation = nil
    local shortestDistance = math.huge

    if titansFolder then
        local playerPosition = getLocalPlayerHumanoidRootPartLocation()
        for _, model in ipairs(titansFolder:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChildOfClass("Humanoid") then
                local hitBoxes = model:FindFirstChild("Hitboxes")
                if hitBoxes then
                    local hit = hitBoxes:FindFirstChild("Hit")
                    if hit then
                        local napePart = hit:FindFirstChild("Nape")
                        if napePart then
                            local distance = (napePart.Position - playerPosition).Magnitude
                            if distance < shortestDistance and distance <= MAX_TELEPORT_DISTANCE2 then
                                shortestDistance = distance
                                closestNapeLocation = napePart
                            end
                        end
                    end
                end
            end
        end
    else
        warn("Titans folder not found in Workspace.")
    end

    if closestNapeLocation then
        nape = closestNapeLocation
        print("Closest NapeLocation set to:", nape.Position)
    else
        warn("No Nape part found within maximum teleport distance.")
    end

    return nape
end

-- Function to start hovering above the Nape
local function startHoveringAboveNape()
    if nape then
        local humanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            local bodyPosition = Instance.new("BodyPosition")
            bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyPosition.Position = nape.Position + Vector3.new(0, 450, 0)
            bodyPosition.Parent = humanoidRootPart

            local bodyGyro = Instance.new("BodyGyro")
            bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
            bodyGyro.CFrame = humanoidRootPart.CFrame
            bodyGyro.Parent = humanoidRootPart

            return bodyPosition, bodyGyro
        end
    else
        warn("Nape not found.")
        return nil, nil
    end
end

-- Function to stop hovering
local function stopHovering(bodyPosition, bodyGyro)
    if bodyPosition then
        bodyPosition:Destroy()
    end
    if bodyGyro then
        bodyGyro:Destroy()
    end
end

-- Function to perform consecutive teleports upon releasing the left mouse button
local function performConsecutiveTeleports()
    local humanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        local originalPosition = humanoidRootPart.Position

        local function teleportTo(position)
            humanoidRootPart.CFrame = CFrame.new(position)
        end

        local function teleport()
            findClosestNapeLocation() -- Update NapeLocation
            if nape then
                local napePosition = nape.Position
                local quarterDistance = (napePosition - originalPosition) / 4
                local threeQuarterDistance = quarterDistance * 3

                for i = 1, 2 do
                    teleportTo(originalPosition + threeQuarterDistance)
                    wait(0.001)
                    teleportTo(napePosition)
                    teleportTo(napePosition)
                    teleportTo(napePosition)
					teleportTo(napePosition)
                end
            end
        end

        teleport()
    end
end

-- Function to handle toggling teleportation
local function toggleTeleportation()
    isTeleportEnabled = not isTeleportEnabled
    tpButtonF.BackgroundColor3 = isTeleportEnabled and Color3.new(0, 1, 0) or Color3.fromRGB(79, 79, 79)
    if isTeleportEnabled then
        print("Teleportation Enabled")
        findClosestNapeLocation()
        local bodyPosition, bodyGyro = startHoveringAboveNape()
        
        -- Keep hovering while teleportation is enabled
        spawn(function()
            while isTeleportEnabled do
                wait(1) -- Cooldown
                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
                wait(0.3)
                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
                findClosestNapeLocation()
                if bodyPosition and bodyGyro then
                    bodyPosition.Position = nape.Position + Vector3.new(0, 300, 0)
                    bodyGyro.CFrame = LocalPlayer.Character.HumanoidRootPart.CFrame
                end
            end
            stopHovering(bodyPosition, bodyGyro)
        end)
    else
        print("Teleportation Disabled")
    end
end

-- Toggle teleportation when button is clicked
tpButtonF.MouseButton1Click:Connect(function()
    toggleTeleportation()
end)

-- Connect the function to the UserInputService's InputEnded event
UserInputService.InputEnded:Connect(function(input)
    if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and isTeleportEnabled == true then
        performConsecutiveTeleports()
    end
end)


-- Function to toggle Frame visibility
local function toggleFrameVisibility()
    if Frame.Visible then
        Frame.Visible = false
        wait(0.35)  -- Delay to match the visibility change
    else
        Frame.Visible = true
        wait(0.35)  -- Delay to match the visibility change
    end
end

-- Connect the function to RightShift key press
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.RightShift then
        toggleFrameVisibility()
    end
end)

local function click()
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
    wait(0.3)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
end

-- Function to simulate a key press
local function simulateKeyPress(key)
    VirtualInputManager:SendKeyEvent(true, key, false, game)
    wait(0.1) -- Brief pause to ensure the key press is registered
    VirtualInputManager:SendKeyEvent(false, key, false, game)
end

-- Function to simulate a touch event
local function simulateTouchEvent(guiObject)
    local pos = guiObject.AbsolutePosition
    local size = guiObject.AbsoluteSize
    VirtualInputManager:SendMouseButtonEvent(pos.X + size.X / 2, pos.Y + size.Y / 2, 0, true, game, 1)
    wait(0.1)
    VirtualInputManager:SendMouseButtonEvent(pos.X + size.X / 2, pos.Y + size.Y / 2, 0, false, game, 1)
end

-- Function to check the status of the blade
local function checkBladeStatus()
    wait(0.72)
    if isTeleportEnabled then
        if childObject.Transparency == 1 or childObject.Parent == nil then
            if pc then
                -- If on PC, simulate pressing the R key
                simulateKeyPress(Enum.KeyCode.R)
                print("Blade refill engaged")
            else
                -- If on mobile, simulate a touch event on the "Refill" button
                local refillButton = player.PlayerGui.Interface.Mobile:FindFirstChild("Refill")
                if refillButton then
                    simulateTouchEvent(refillButton)
                    print("Blade refill engaged")
                end
            end
        end
    else
        print("Auto blade refill is not turned on")
    end
end

-- Connect the Transparency property changed signal
childObject:GetPropertyChangedSignal("Transparency"):Connect(checkBladeStatus)

-- Connect the AncestryChanged event to detect when the part's parent changes
childObject.AncestryChanged:Connect(checkBladeStatus)
local retryButtonTitle = player.PlayerGui.Interface.Rewards.Main.Info.Main.Buttons.Retry.Title 

local VirtualInputManager = game:GetService("VirtualInputManager")

-- Estimación de la zona donde se encuentra el botón
local buttonAreaX = retryButtonTitle.AbsolutePosition.X + retryButtonTitle.AbsoluteSize.X / 2
local buttonAreaYStart = retryButtonTitle.AbsolutePosition.Y - 50  -- Comenzar 50 píxeles más abajo
local buttonAreaYEnd = buttonAreaYStart + retryButtonTitle.AbsoluteSize.Y + 100 -- Extender el área 100 píxeles hacia abajo

local numClicks = 10 -- Número de clics a realizar
local clickSpacing = 10 -- Distancia vertical entre clics
local clickInterval = 3 -- Intervalo entre cada conjunto de clics (en segundos)

-- Función para realizar los clics en el área del botón
local function clickRetryArea()
    for i = 1, numClicks do
        local clickY = buttonAreaYEnd - (i - 1) * clickSpacing -- Empezar desde abajo
        VirtualInputManager:SendMouseButtonEvent(buttonAreaX, clickY, 0, true, game, 0)
        VirtualInputManager:SendMouseButtonEvent(buttonAreaX, clickY, 0, false, game, 0)
        wait(0.1) -- Pequeña pausa entre clics
    end
end

-- Función para ejecutar el auto-retry en un hilo separado
local function autoRetryThread()
    while wait(clickInterval) do
        if not string.find(retryButtonTitle.Text, "(0/0)") then  -- Verificar si el texto NO contiene "(0/0)"
            clickRetryArea()

            -- Esperar a que el texto cambie a "STARTING"
            while not string.find(retryButtonTitle.Text, "STARTING") do
                wait()
                clickRetryArea()
            end

            print("Script stopped. Title text changed to STARTING.")
            break -- Salir del bucle después de que el texto cambie
        end
    end
end

-- Iniciar el hilo del auto-retry (activado por defecto)
coroutine.wrap(autoRetryThread)()

toggleTeleportation()
